{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"scpn-quantum-control","text":"<p>Quantum simulation of coupled oscillators on IBM superconducting hardware.</p>"},{"location":"#what-this-does","title":"What this does","text":"<p>The Self-Consistent Phenomenological Network (SCPN) models hierarchical dynamics as 16 coupled Kuramoto oscillators with a coupling matrix K_nm. The Kuramoto model maps directly to the XY spin Hamiltonian \u2014 superconducting qubits simulate it natively via Trotterized time evolution.</p> <p>This package compiles SCPN coupling parameters into Qiskit circuits and runs them on IBM Heron r2 hardware (156 qubits).</p>"},{"location":"#key-results","title":"Key results","text":"Result Value VQE ground-state error 0.05% (4-qubit, ibm_fez) 16-layer UPDE snapshot 46% error at depth 770 (NISQ-consistent) Decoherence curve 12 points, depth 5\u2192770 Coherence wall depth 250-400 (Heron r2) Test suite 456 passing"},{"location":"#modules","title":"Modules","text":"Module Purpose <code>bridge</code> K_nm \u2192 Hamiltonian, ansatz, circuit converters <code>phase</code> Kuramoto XY solver, VQE, UPDE-16, Trotter <code>control</code> QAOA-MPC, VQLS Grad-Shafranov, Petri nets, disruption classifier <code>qsnn</code> Quantum spiking neural networks (LIF, STDP, synapses) <code>crypto</code> Topology-authenticated QKD, Bell tests, key rates, percolation <code>qec</code> Toric code + MWPM decoder with K_nm-weighted distances <code>mitigation</code> ZNE (unitary folding) + dynamical decoupling (XY4, X2, CPMG) <code>hardware</code> IBM Quantum runner, 20 pre-built experiments, classical references"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>from scpn_quantum_control.bridge import OMEGA_N_16, build_knm_paper27\nfrom scpn_quantum_control.phase import QuantumKuramotoSolver\n\nK = build_knm_paper27(L=4)\nomega = OMEGA_N_16[:4]\nsolver = QuantumKuramotoSolver(4, K, omega)\nresult = solver.run(t_max=0.5, dt=0.1, trotter_per_step=2)\nprint(f\"R(t): {result['R']}\")\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Installation \u2014 pip install + dev setup</li> <li>Quickstart \u2014 first experiment in 5 minutes</li> <li>Orchestrator Integration \u2014 fusion-defined Kuramoto/UPDE specs into quantum lanes</li> <li>API Reference \u2014 full module documentation</li> <li>Hardware Guide \u2014 IBM Quantum setup</li> </ul>"},{"location":"EXPERIMENT_ROADMAP/","title":"Experiment Roadmap: March-June 2026","text":"<p>Backend: ibm_fez (Heron r2, 156 qubits) Budget: 10 min QPU / month (free tier) Repository: scpn-quantum-control v0.6.4</p>"},{"location":"EXPERIMENT_ROADMAP/#experiment-inventory-20-total","title":"Experiment Inventory (20 total)","text":"# Experiment Qubits Est. QPU Month Science Question 1 <code>noise_baseline</code> 4 10s Mar Calibration drift Feb\u2192Mar 2 <code>kuramoto_4osc_zne</code> [1,3,5] 4 90s Mar Raw vs mitigated (linear ZNE) 3 <code>kuramoto_8osc_zne</code> [1,3,5] 8 120s Mar Extend mitigation to depth-233 4 <code>vqe_8q_hardware</code> 8 60s Mar Scale VQE from 4\u21928 qubits 5 <code>upde_16_dd</code> 16 60s Mar DD on full 16-layer system 6 <code>kuramoto_4osc_trotter2</code> 4 30s Mar Order-2 vs order-1 Trotter 7 <code>sync_threshold</code> 4 50s Apr Kuramoto phase transition 8 <code>ansatz_comparison_hw</code> 4 90s Apr Prove Knm ansatz wins on hardware 9 <code>zne_higher_order</code> [1..9] 4 120s Apr Optimal extrapolation order 10 <code>decoherence_scaling</code> 2-12 120s Apr Extract per-gate decay rate \u03b3 11 <code>vqe_landscape</code> 4 0s Apr Barren plateau detection (sim only) 12 <code>kuramoto_4osc</code> 4 30s \u2014 Baseline (Feb, done) 13 <code>kuramoto_8osc</code> 8 60s \u2014 8-osc trajectory (Feb, done) 14 <code>vqe_4q</code> 4 30s \u2014 VQE ground state (Feb, done) 15 <code>vqe_8q</code> 8 0s \u2014 Statevector only (Feb, done) 16 <code>qaoa_mpc_4</code> 4 20s \u2014 Binary MPC (Feb, done) 17 <code>upde_16_snapshot</code> 16 180s \u2014 16-layer snapshot (Feb, done) 18 <code>bell_test_4q</code> 4 ~20s Mar CHSH violation certifies K_nm entanglement 19 <code>correlator_4q</code> 4 ~25s Mar ZZ cross-correlation validates K_ij topology 20 <code>qkd_qber_4q</code> 4 ~15s Mar QBER from hardware vs BB84 threshold"},{"location":"EXPERIMENT_ROADMAP/#march-2026-plan-370s-qpu","title":"March 2026 Plan (~370s QPU)","text":""},{"location":"EXPERIMENT_ROADMAP/#priority-experiments","title":"Priority experiments","text":"<p>1. noise_baseline (10s) \u2014 Repeat Feb depth-5 circuit. Detects backend drift. Compare hw_R to Feb value (0.8054). If drift &gt; 2%, flag all subsequent results for calibration correction.</p> <p>2. kuramoto_4osc_zne [1,3,5] (90s) \u2014 Gate-fold at 3 noise scales, Richardson linear extrapolation. Feb baseline: 7.3% error at depth 85. Expected: ZNE reduces to ~3-4%. Produces the \"raw vs mitigated\" figure for the paper.</p> <p>3. kuramoto_8osc_zne [1,3,5] (120s) \u2014 Same ZNE protocol at 8 qubits. Feb: 20% error at depth 233. Expected: ZNE reduces to ~10-12%. Key question: does ZNE maintain effectiveness at higher depth?</p> <p>4. vqe_8q_hardware (60s) \u2014 Statevector VQE optimization followed by single-shot hardware energy evaluation. Feb 4q result: 0.05% error. Expected 8q: 0.1-0.5% error (deeper ansatz, more CZ gates). Establishes scaling trend for VQE accuracy.</p> <p>5. upde_16_dd (60s) \u2014 XY4 dynamical decoupling on all 16-qubit UPDE basis circuits. Compares R(DD) vs R(no-DD) vs classical. Tests whether idle-qubit DD helps at depth ~770 where decoherence dominates.</p> <p>6. kuramoto_4osc_trotter2 (30s) \u2014 Suzuki-Trotter order 2 at identical dt/steps as order 1. Direct comparison: does higher Trotter order gain accuracy faster than decoherence penalty from deeper circuits?</p> <p>Total: ~370s. Buffer: ~230s for reruns or calibration.</p>"},{"location":"EXPERIMENT_ROADMAP/#april-2026-plan-380s-qpu","title":"April 2026 Plan (~380s QPU)","text":""},{"location":"EXPERIMENT_ROADMAP/#priority-experiments_1","title":"Priority experiments","text":"<p>7. sync_threshold (50s) \u2014 Sweep K_base \u2208 {0.05, 0.15, 0.30, 0.45, 0.60, 0.80} at 4 qubits. Each value = 3 circuits (Z/X/Y) at dt=0.1. Maps the Kuramoto synchronization bifurcation on quantum hardware: below critical coupling K_c, R stays low; above K_c, R jumps to order ~0.5+.</p> <p>Science value: first quantum measurement of the Kuramoto phase transition. Validates quantum XY \u2194 classical Kuramoto correspondence at the critical point. Publication-quality standalone result.</p> <p>8. ansatz_comparison_hw (90s) \u2014 Three VQE ansatze (Knm-informed, TwoLocal, EfficientSU2) optimized on Statevector, then evaluated on hardware via Estimator. Compares hw_energy for each.</p> <p>Science value: Feb sim-only benchmark showed Knm-informed converges fastest. This proves the advantage survives real hardware noise. Physics-informed circuit design is a hot topic \u2014 demonstrating it on real hardware is publishable in PRX Quantum or similar.</p> <p>9. zne_higher_order [1,3,5,7,9] (120s) \u2014 5-point ZNE with polynomial orders 1 (linear) and 2 (quadratic). Tests whether higher-order extrapolation recovers more signal or overfits.</p> <p>Science value: systematic ZNE study on the same circuit family. Determines optimal extrapolation strategy for XY evolution on Heron r2. Contributes to the error mitigation literature.</p> <p>10. decoherence_scaling (120s) \u2014 Run 1-Trotter-step evolution at 2, 4, 6, 8, 10, 12 qubits. Records depth and R for each. Fits R_hw = R_exact * exp(-\u03b3 * depth) to extract per-gate depolarization rate \u03b3.</p> <p>Science value: \u03b3 is a single number that characterizes the backend for our circuit family. Enables predictive modeling: \"at depth D, expect error E.\" Compares to IBM published T1/T2 and gate errors.</p> <p>11. vqe_landscape (0s QPU, sim only) \u2014 Sample 50 random parameter vectors for each ansatz, compute energy variance. Low variance = barren plateau. Tests whether Knm-informed ansatz avoids barren plateaus.</p> <p>Science value: barren plateaus are the #1 obstacle to VQE scaling. Showing Knm-informed ansatz has higher variance (trainable landscape) is publishable. Reference: McClean et al., Nature Comm. 9, 4812 (2018).</p> <p>Total: ~380s. Buffer: ~220s.</p>"},{"location":"EXPERIMENT_ROADMAP/#may-2026-plan-candidates","title":"May 2026 Plan (Candidates)","text":""},{"location":"EXPERIMENT_ROADMAP/#experiment-ideas-not-yet-implemented","title":"Experiment ideas (not yet implemented)","text":"<p>A. Layer-selective qubit assignment \u2014 On Heron r2, assign strongly-coupled SCPN layers (L3, L4, L10) to the lowest-error physical qubits. Compare UPDE-16 R vs default Qiskit layout.</p> <p>Budget: ~120s QPU. Requires reading backend calibration data (<code>backend.properties()</code>) to rank qubits by error rate.</p> <p>B. Readout error mitigation (M3) \u2014 Build measurement calibration matrix from all-0 and all-1 circuits, apply inverse to 4-osc and 8-osc counts. Separates readout error from gate error.</p> <p>Budget: ~30s QPU (calibration circuits) + reprocessing of existing data.</p> <p>C. Entanglement entropy measurement \u2014 Compute von Neumann entropy S(\u03c1_q) of per-qubit reduced density matrices during Kuramoto evolution. Requires randomized measurements (shadow tomography) or direct state tomography on \u22644 qubits.</p> <p>Budget: ~180s QPU for 4-qubit partial tomography at 3 time steps.</p> <p>D. QAOA with ZZ coupling terms \u2014 Extend binary MPC cost Hamiltonian to include inter-timestep correlations (ZZ terms). Tests whether richer cost structure improves QAOA control quality.</p> <p>Budget: ~60s QPU. Requires extending <code>QAOA_MPC.build_cost_hamiltonian()</code>.</p> <p>E. Depth-optimal circuit decomposition \u2014 Rewrite Kuramoto evolution using native Heron r2 CZ+RZ+SX gate set directly (skip Trotter synthesis). Hand-optimized 4-qubit circuit should be 40-60% shallower.</p> <p>Budget: ~30s QPU. High implementation effort but large depth savings.</p>"},{"location":"EXPERIMENT_ROADMAP/#june-2026-plan-candidates","title":"June 2026 Plan (Candidates)","text":"<p>F. Quantum phase estimation \u2014 QPE on the XY Hamiltonian to extract eigenvalues. 4 qubits + 3 ancilla. Tests whether QPE is practical on NISQ for our Hamiltonian.</p> <p>G. Variational quantum simulation \u2014 VQS (Li-Benjamin algorithm) as alternative to Trotter. Uses ansatz evolution instead of product formulas. Should be shallower for same accuracy.</p> <p>H. Multi-circuit quantum error correction \u2014 Run toric code d=3 with MWPM decoder using Knm-weighted distances. Tests whether physics-aware decoding reduces logical error rate.</p>"},{"location":"EXPERIMENT_ROADMAP/#paper-claims-strengthened-by-this-roadmap","title":"Paper Claims Strengthened by This Roadmap","text":"Claim Feb Data March+ Extension VQE 0.05% 4q 8q (scaling proof) Decoherence curve 12 pts, qualitative Fit \u03b3, R\u00b2 (quantitative) 16-layer UPDE 46% error DD + ZNE (reduced error) Trotter tradeoff Order 1 only Order 1 vs 2 comparison Error mitigation None ZNE linear + quadratic Ansatz design Sim only Hardware proof Phase transition Not measured Bifurcation curve Barren plateaus Not measured Landscape variance"},{"location":"EXPERIMENT_ROADMAP/#hardware-notes","title":"Hardware Notes","text":"<ul> <li>Backend: ibm_fez, Heron r2, 156 qubits</li> <li>Native gates: CZ, ID, RZ, SX, X</li> <li>Median CZ error: ~0.5%</li> <li>T1/T2: ~300/200 \u03bcs</li> <li>Coherence wall: depth 250-400 (Feb calibration)</li> <li>Budget: 10 min QPU/month (free tier)</li> <li>Scheduling: first-come-first-served, typical queue 30s-5min</li> </ul>"},{"location":"PAPER_CLAIMS/","title":"Paper Claims: Quantum Simulation of Kuramoto Phase Dynamics on NISQ Hardware","text":""},{"location":"PAPER_CLAIMS/#target-venue","title":"Target Venue","text":"<p>Physical Review Research, Quantum Science and Technology, or npj Quantum Information.</p>"},{"location":"PAPER_CLAIMS/#proposed-title","title":"Proposed Title","text":"<p>\"Quantum simulation of coupled-oscillator synchronization on a 156-qubit superconducting processor\"</p>"},{"location":"PAPER_CLAIMS/#abstract-draft","title":"Abstract Draft","text":"<p>We implement quantum simulation of Kuramoto-type coupled oscillators on IBM's Heron r2 processor (ibm_fez, 156 qubits) by mapping the Kuramoto model to the XY spin Hamiltonian and evolving via Lie-Trotter decomposition. Five principal results emerge: (1) a physics-informed VQE ansatz whose entanglement topology mirrors the coupling graph achieves 0.05% ground-state energy error on 4 qubits, matching the best reported VQE accuracies on comparable Hamiltonians; (2) a 12-point decoherence scaling curve from depth 5 to 770 identifies three distinct regimes with a coherence wall at depth 250-400; (3) a 16-oscillator snapshot preserves per-layer structure at extremes (L12 collapse, L3 resilience) despite 46% global error \u2014 overall Spearman rho = -0.13 indicates hardware noise dominates over coupling topology for mid-range layers; (4) a Trotter-depth tradeoff shows single-step evolution outperforms multi-step on current hardware; (5) QAOA-based model predictive control finds lower-cost action sequences than brute-force search. All experiments ran within a 10-minute free-tier QPU budget.</p>"},{"location":"PAPER_CLAIMS/#claim-1-physics-informed-vqe-achieves-005-ground-state-error","title":"Claim 1: Physics-Informed VQE Achieves 0.05% Ground-State Error","text":"<p>Data: <code>results/hw_vqe_4q.json</code></p> Metric Hardware Simulator Exact Energy -6.2998 -6.3028 -6.3030 Error 0.05% 0.004% -- <p>Novelty: The ansatz places CZ gates only between qubit pairs (i,j) where K[i,j] &gt; threshold, matching the physical coupling topology. Generic ansatze (e.g. TwoLocal with linear entanglement) require more parameters and deeper circuits for the same accuracy, because they waste gates on physically disconnected pairs.</p> <p>Context: Kandala et al. (Nature 2017) reported ~1.5% error on 6-qubit H2/LiH VQE. Peruzzo et al. (Nature Comms 2014) reported 2% on HeH+. Our 0.05% on a domain-specific Hamiltonian with a physics-matched ansatz is competitive with current best.</p> <p>Reproducibility: Backend ibm_fez, COBYLA 100 iterations, Knm-informed Ry/Rz + CZ ansatz, 12 two-qubit gates. Job details in JSON.</p> <p>What strengthens this for publication: - Run VQE at 8 qubits (56 CZ gates, still within coherence window) to show scaling - Compare against TwoLocal and EfficientSU2 ansatze on same Hamiltonian - Add ZNE error mitigation to show pre/post-mitigation comparison</p>"},{"location":"PAPER_CLAIMS/#claim-2-12-point-decoherence-scaling-curve-with-three-regimes","title":"Claim 2: 12-Point Decoherence Scaling Curve with Three Regimes","text":"<p>Data: Master table in <code>results/HARDWARE_RESULTS.md</code>, individual JSONs for each data point.</p> Regime Depth Error Mechanism Readout-dominated &lt; 150 &lt; 10% Shot noise + readout assignment error Linear decoherence 150-400 15-35% Gate errors accumulate linearly with depth Saturation &gt; 400 &gt; 35% R approaches noise floor (~0.1) <p>Novelty: Most decoherence studies use random circuits or GHZ states. This curve uses a physically motivated Hamiltonian (XY model with SCPN coupling parameters) and measures a physics-relevant observable (Kuramoto order parameter R). The regime boundaries are specific to Heron r2 (Feb 2026 calibration) and useful for planning future experiments.</p> <p>Key data points: - Noise baseline: depth 5, R=0.8054, error 0.1% (proves readout is clean) - Coherence wall entry: depth ~250, error ~20% - Deep decoherence: depth 770, R=0.332, error 46%</p> <p>What strengthens this for publication: - Fit exponential decay model: R_hw = R_exact * exp(-gamma * depth) + R_noise - Extract gamma (depolarization rate per gate layer) and compare to IBM calibration data - Repeat noise baseline monthly to track calibration drift (first data point: March)</p>"},{"location":"PAPER_CLAIMS/#claim-3-16-oscillator-snapshot-preserves-per-layer-structure-at-extremes","title":"Claim 3: 16-Oscillator Snapshot Preserves Per-Layer Structure at Extremes","text":"<p>Data: <code>results/hw_upde_16_snapshot.json</code></p> <p>Per-layer || at dt=0.05 (ordered strongest to weakest): <p>| Layer | || | Knm row sum | Rank (Knm) | |-------|--------|-------------|------------| | L10 | 0.640 | 2.41 | 4 | | L4 | 0.587 | 2.79 | 2 | | L3 | 0.551 | 2.93 | 1 | | L14 | 0.448 | 2.10 | 8 | | L16 | 0.441 | 1.47 | 14 | | L8 | 0.429 | 2.27 | 5 | | L1 | 0.387 | 2.09 | 9 | | L5 | 0.366 | 2.54 | 3 | | L13 | 0.354 | 2.15 | 7 | | L7 | 0.322 | 2.24 | 6 | | L9 | 0.321 | 2.08 | 10 | | L15 | 0.231 | 1.62 | 13 | | L2 | 0.187 | 2.07 | 11 | | L11 | 0.186 | 1.85 | 12 | | L12 | 0.020 | 1.42 | 15 | <p>L12 (weakest Knm coupling, row sum 1.42) shows near-complete decoherence (||=0.02), while L3 (strongest coupling, row sum 2.93) maintains ||=0.55. <p>Statistical test: Spearman rank correlation between || and Knm row sum yields rho = -0.13, p = 0.62 \u2014 not significant. The Knm row sums are too uniform (range 1.42-2.93 across 16 layers) to drive the coherence variation. The dominant factor is likely qubit-to-qubit T1/T2 variation across the 156-qubit chip, not coupling topology. <p>However, the outlier structure is physically meaningful: - L12 (weakest Knm row sum = 1.42) has near-zero coherence (||=0.02) - L3 (strongest Knm row sum = 2.93) maintains high coherence (||=0.55) - The extremes follow coupling, even if the middle layers don't <p>Novelty: 16-oscillator snapshot preserves per-layer structure at extremes despite 46% global error. The outlier analysis (L12 collapse, L3 resilience) provides a testable prediction: dynamical decoupling on weakly-coupled qubits should disproportionately improve their coherence.</p> <p>What strengthens this for publication: - Run with dynamical decoupling: does L12 recover? - Request per-qubit T1/T2 calibration data from IBM to separate chip noise from physics - Compute Bloch vector magnitude sqrt(X^2 + Y^2 + Z^2) per layer (richer metric) - Compare per-layer coherence at dt=0.05 vs dt=0.10 (data exists for both)</p>"},{"location":"PAPER_CLAIMS/#claim-4-trotter-depth-tradeoff-fewer-reps-wins-on-nisq","title":"Claim 4: Trotter-Depth Tradeoff \u2014 Fewer Reps Wins on NISQ","text":"<p>Data: 4-oscillator at t=0.1</p> Trotter reps Depth hw_R exact_R Error 1 85 0.743 0.802 7.3% 2 149 0.666 0.802 16.9% 4 290 0.625 0.802 22.0% <p>Each additional Trotter rep adds ~75 depth. The Trotter error reduction (~O(dt^2) per step) is dwarfed by the decoherence penalty (~3% error per 25 depth on Heron r2).</p> <p>Crossover estimate: Trotter error &lt; decoherence penalty when depth &lt; 100 on current hardware. For t=0.1 with 4 oscillators, 1 Trotter rep is optimal.</p> <p>Novelty: While the principle is known (Clinton et al., Nature Physics 2024), demonstrating it on a physics-relevant Hamiltonian with exact reference values provides a concrete protocol for choosing Trotter depth on Heron-class hardware.</p> <p>What strengthens this for publication: - Compute Trotter error analytically: ||U_exact - U_trotter|| - Plot error budget: Trotter error + decoherence error vs depth - Show the crossover point where adding reps becomes counterproductive</p>"},{"location":"PAPER_CLAIMS/#claim-5-qaoa-mpc-finds-better-solutions-than-brute-force","title":"Claim 5: QAOA-MPC Finds Better Solutions than Brute Force","text":"<p>Data: <code>results/hw_qaoa_mpc_4.json</code></p> Method Cost Actions Brute-force optimal 0.250 [0,0,0,0] QAOA p=1 (hardware) -0.034 [1,1,0,0] QAOA p=2 (hardware) -0.514 [1,1,1,0] <p>QAOA finds lower-cost solutions than brute-force enumeration because the Ising encoding allows negative costs that the binary enumeration misses (the brute-force evaluates the original MPC cost, while QAOA minimizes the Ising encoding which includes constant offsets).</p> <p>Caveat: This is a proof-of-concept on a 4-bit problem. The optimizer loop ran on hardware (78 jobs for COBYLA iterations), which is budget-inefficient. Future work should use simulator for optimization, hardware for final evaluation.</p> <p>What strengthens this for publication: - Scale to horizon 8 (8 qubits, ~200 depth, within coherence) - Compare against classical COBYLA on same cost function - Use SamplerV2 with error mitigation</p>"},{"location":"PAPER_CLAIMS/#figure-plan","title":"Figure Plan","text":""},{"location":"PAPER_CLAIMS/#figure-1-decoherence-scaling-curve","title":"Figure 1: Decoherence Scaling Curve","text":"<ul> <li>X-axis: circuit depth (log scale)</li> <li>Y-axis: relative error (%)</li> <li>Data: 12 points from master table</li> <li>Three colored regions for the regimes</li> <li>Exponential fit overlay</li> <li>Script: <code>scripts/plot_decoherence_curve.py</code></li> </ul>"},{"location":"PAPER_CLAIMS/#figure-2-vqe-convergence","title":"Figure 2: VQE Convergence","text":"<ul> <li>X-axis: COBYLA iteration</li> <li>Y-axis: VQE energy</li> <li>Three traces: hardware, simulator, exact (horizontal line)</li> <li>Inset: ansatz circuit diagram showing Knm-matched CZ topology</li> </ul>"},{"location":"PAPER_CLAIMS/#figure-3-per-layer-coherence-vs-coupling-strength","title":"Figure 3: Per-Layer Coherence vs Coupling Strength","text":"<ul> <li>X-axis: Knm row sum (coupling strength)</li> <li>Y-axis: || (qubit coherence) <li>16 labeled points (one per SCPN layer)</li> <li>Spearman rho = -0.13 annotation (honest: not significant)</li> <li>L12 (near-dead) and L3 (resilient) highlighted as outlier pair</li> <li>Script: <code>scripts/plot_layer_coherence.py</code></li>"},{"location":"PAPER_CLAIMS/#figure-4-trotter-depth-tradeoff","title":"Figure 4: Trotter Depth Tradeoff","text":"<ul> <li>X-axis: circuit depth</li> <li>Y-axis: order parameter R</li> <li>Hardware points + exact reference line</li> <li>Error budget decomposition (Trotter vs decoherence)</li> </ul>"},{"location":"PAPER_CLAIMS/#figure-5-upde-16-layer-map","title":"Figure 5: UPDE-16 Layer Map","text":"<ul> <li>16-bar chart of per-layer || at dt=0.05 <li>Color-coded by decoherence severity</li> <li>Comparison bar for classical Kuramoto phase magnitudes</li>"},{"location":"PAPER_CLAIMS/#experiments-needed-march-qpu-budget","title":"Experiments Needed (March QPU Budget)","text":"Experiment Budget (s) Strengthens Claim VQE 8-qubit on hardware ~30 Claim 1 (scaling) VQE with TwoLocal ansatz (4q, same params) ~15 Claim 1 (ansatz comparison) ZNE on kuramoto 4-osc ~60 Claim 2 (mitigation baseline) Noise baseline repeat ~10 Claim 2 (drift tracking) UPDE-16 with dynamical decoupling ~60 Claim 3 (DD vs no-DD) Kuramoto 4-osc, Trotter reps 8 ~30 Claim 4 (extended curve) QAOA-MPC horizon 8 ~100 Claim 5 (scaling) Total ~305 Half of monthly budget"},{"location":"PAPER_CLAIMS/#claim-6-crypto-k_nm-topology-authenticated-qkd","title":"Claim 6 (Crypto): K_nm Topology-Authenticated QKD","text":"<p>Status: Simulator-validated, hardware experiment wrappers implemented (v0.6.4).</p> <p>Thesis: The SCPN coupling matrix K_nm encodes oscillator topology as quantum entanglement structure under the Kuramoto-XY isomorphism. Parties sharing K_nm generate correlated measurement statistics from H(K_nm)'s ground state \u2014 an eavesdropper without K_nm cannot reconstruct these correlations.</p> <p>Hardware experiments (awaiting March QPU budget): - <code>bell_test_4q</code>: CHSH S-value from 4 measurement basis combinations - <code>correlator_4q</code>: 4x4 connected ZZ correlation matrix - <code>qkd_qber_4q</code>: Z-basis and X-basis QBER vs BB84 threshold (&lt; 0.11)</p> <p>What strengthens this for publication: - Demonstrate CHSH violation (S &gt; 2) on hardware with optimized VQE convergence - Show QBER &lt; 0.11 on hardware (positive Devetak-Winter key rate) - Compare hardware correlation matrix to exact correlator matrix (Frobenius error) - Scale to 8-qubit correlator for richer topology validation</p> <p>Separate publication track: These results are independent of the phase dynamics paper (Claims 1-5) and could form a standalone letter to PRA/PRL on topology-authenticated quantum key distribution.</p>"},{"location":"PAPER_CLAIMS/#timeline","title":"Timeline","text":"Milestone Target March experiments complete 2026-03-15 Spearman correlation + fit analysis 2026-03-20 All 5 figures generated 2026-03-25 Draft manuscript (phase dynamics) 2026-04-15 Crypto hardware data collected 2026-04-01 Internal review 2026-04-30 Submission 2026-05-15"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/","title":"Quantum Cryptography Research Branch","text":""},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#thesis","title":"Thesis","text":"<p>The SCPN coupling matrix K_nm encodes oscillator topology as quantum entanglement structure under the Kuramoto-XY isomorphism. Parties who share K_nm can generate correlated measurement statistics from the Hamiltonian's ground state \u2014 an eavesdropper without K_nm cannot reconstruct these correlations. This gives a topology-authenticated QKD protocol where the shared secret is not a bit string but a physical coupling matrix.</p>"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#literature-grounding","title":"Literature Grounding","text":"Paper Key Result K_nm Connection Frequency-bin QKD (npj Quantum Inf. 2025) Coupled ring resonators implement BBM92 via coupling topology K_nm maps to photonic coupling graph Huygens quantum sync (Nature Comms. 2025) Coupled oscillators under shared noise co-generate phase sync + entanglement Kuramoto sync = entanglement generation Quantum network science (AAAI 2025) Fidelity-weighted graph structure determines key rate K_nm spectral properties set QKD channel capacity Entanglement percolation (arXiv 2026) Mixed-state threshold lower than pure-state Weak K_nm entries still contribute above threshold Hierarchical group QKD (Sci. Reports 2025) Multi-party protocol with sub-group key derivation 16-layer hierarchy = natural key tree"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#module-architecture","title":"Module Architecture","text":"<pre><code>scpn_quantum_control/\n\u2514\u2500\u2500 crypto/                    # Topology-authenticated quantum cryptography\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 knm_key.py             # K_nm \u2192 key material pipeline\n    \u251c\u2500\u2500 topology_auth.py       # Spectral fingerprint authentication\n    \u251c\u2500\u2500 entanglement_qkd.py    # Entanglement-based key distribution\n    \u251c\u2500\u2500 percolation.py         # K_nm entanglement percolation analysis\n    \u251c\u2500\u2500 hierarchical_keys.py   # Multi-layer key derivation from SCPN\n    \u2514\u2500\u2500 noise_analysis.py      # Devetak-Winter key rates, noise channels\n\ntests/\n\u251c\u2500\u2500 test_knm_key.py\n\u251c\u2500\u2500 test_topology_auth.py\n\u251c\u2500\u2500 test_entanglement_qkd.py\n\u251c\u2500\u2500 test_percolation.py\n\u251c\u2500\u2500 test_hierarchical_keys.py\n\u2514\u2500\u2500 test_noise_analysis.py\n</code></pre>"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#module-specifications","title":"Module Specifications","text":""},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#1-knm_keypy-coupling-matrix-to-key-material","title":"1. <code>knm_key.py</code> \u2014 Coupling Matrix to Key Material","text":"<p>Core primitive: Given shared K_nm and agreed Hamiltonian H(K_nm), prepare the ground state |\u03c8\u2080\u27e9, measure in agreed basis, extract correlated bit string.</p> <pre><code>Pipeline:\n  K_nm \u2192 knm_to_hamiltonian(K) \u2192 VQE ground state \u2192 measurement \u2192 sift \u2192 key\n</code></pre> <p>Functions: - <code>prepare_key_state(K, omega, ansatz_reps)</code> \u2192 QuantumCircuit   Builds VQE-optimized circuit encoding K_nm's ground state. - <code>extract_raw_key(counts, basis, n_qubits)</code> \u2192 BitArray   Sifts measurement results into raw key bits. - <code>estimate_qber(alice_bits, bob_bits)</code> \u2192 float   Quantum bit error rate from shared subset. - <code>privacy_amplification(raw_key, qber)</code> \u2192 SecureKey   Universal\u2082 hash family compression.</p> <p>Security argument: K_nm has 16\u00d715/2 = 120 independent off-diagonal entries (symmetric, zero diagonal). Each entry is a continuous real value. An eavesdropper must reconstruct all 120 values to reproduce the ground state \u2014 the search space is R^120. Measurement statistics from a wrong K_nm' produce statistically distinguishable correlations (detectable via QBER &gt; threshold).</p>"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#2-topology_authpy-spectral-fingerprint-authentication","title":"2. <code>topology_auth.py</code> \u2014 Spectral Fingerprint Authentication","text":"<p>Core idea: The Laplacian spectrum of K_nm (already computed by SSGF's <code>spectral.py</code>) provides a public authentication token. The Fiedler value \u03bb\u2081 and spectral gap \u03bb\u2081/\u03bb\u2082 uniquely characterize the coupling topology without revealing K_nm itself.</p> <p>Functions: - <code>spectral_fingerprint(K)</code> \u2192 dict   Returns {fiedler, gap_ratio, spectral_entropy, n_components}. - <code>verify_fingerprint(K, fingerprint, tol)</code> \u2192 bool   Checks K against a claimed fingerprint. - <code>topology_distance(fp1, fp2)</code> \u2192 float   Metric between two fingerprints for drift detection.</p> <p>Why it works: Spectral properties are graph invariants \u2014 many different K_nm matrices share the same spectrum (co-spectral graphs). Publishing the spectrum doesn't reveal K_nm, but any party with the true K_nm can verify consistency.</p>"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#3-entanglement_qkdpy-topology-authenticated-qkd","title":"3. <code>entanglement_qkd.py</code> \u2014 Topology-Authenticated QKD","text":"<p>Protocol (SCPN-QKD): 1. Alice and Bob share K_nm (pre-distributed secret). 2. Both construct H(K_nm) and prepare ground state |\u03c8\u2080\u27e9. 3. Alice measures qubits {0,...,7} in random {X, Z} basis. 4. Bob measures qubits {8,...,15} in random {X, Z} basis. 5. Public channel: announce basis choices, keep matching. 6. Sift \u2192 estimate QBER \u2192 privacy amplify \u2192 secure key.</p> <p>Functions: - <code>scpn_qkd_protocol(K, omega, alice_qubits, bob_qubits, shots)</code> \u2192 QKDResult   Full protocol execution on simulator. - <code>correlator_matrix(counts, alice_qubits, bob_qubits)</code> \u2192 ndarray   Cross-correlation matrix between Alice and Bob measurements. - <code>bell_inequality_test(correlator)</code> \u2192 dict   CHSH violation test to certify entanglement.</p> <p>Key rate bound: From the Devetak-Winter formula, r \u2265 1 - h(QBER) - h(QBER) where h is binary entropy. The topology-dependent entanglement structure means different qubit pairs have different key rates \u2014 strongly coupled pairs (K_nm &gt; 0.2) yield higher rates.</p>"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#4-percolationpy-entanglement-percolation-on-k_nm","title":"4. <code>percolation.py</code> \u2014 Entanglement Percolation on K_nm","text":"<p>Core question: Which (n,m) pairs in K_nm are entangled above threshold and usable as QKD channels?</p> <p>Functions: - <code>concurrence_map(K, omega)</code> \u2192 ndarray   Compute pairwise concurrence from ground state reduced density matrices. - <code>percolation_threshold(K)</code> \u2192 float   Minimum K_nm value for end-to-end entanglement. - <code>active_channel_graph(K, threshold)</code> \u2192 nx.Graph   Graph of above-threshold entangled pairs. - <code>key_rate_per_channel(concurrence_map)</code> \u2192 ndarray   Devetak-Winter key rate for each link.</p> <p>Connection to SSGF: The Fiedler value \u03bb\u2081 from SSGF's spectral bridge is the algebraic connectivity \u2014 when \u03bb\u2081 &gt; 0, the graph is connected and end-to-end entanglement percolates.</p>"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#5-hierarchical_keyspy-scpn-layer-key-derivation","title":"5. <code>hierarchical_keys.py</code> \u2014 SCPN Layer Key Derivation","text":"<p>Core idea: The 16-layer SCPN hierarchy maps to a key tree.</p> <pre><code>Master key: hash(K_nm_full \u2016 R_global)\n  \u251c\u2500\u2500 L1 subkey: hash(K_nm[0,:] \u2016 \u03b8\u2081(t))\n  \u251c\u2500\u2500 L2 subkey: hash(K_nm[1,:] \u2016 \u03b8\u2082(t))\n  \u251c\u2500\u2500 ...\n  \u2514\u2500\u2500 L16 subkey: hash(K_nm[15,:] \u2016 \u03b8\u2081\u2086(t))\n</code></pre> <p>Functions: - <code>derive_master_key(K, R_global, nonce)</code> \u2192 bytes   Master key from full coupling matrix + order parameter. - <code>derive_layer_key(K, layer_idx, phase_sequence, nonce)</code> \u2192 bytes   Layer-specific subkey. - <code>key_hierarchy(K, phases, n_layers)</code> \u2192 dict[int, bytes]   Full hierarchy derivation. - <code>verify_key_chain(master, layer_keys, K)</code> \u2192 bool   Verify layer keys are consistent with master.</p> <p>Time-varying keys: The Kuramoto phase sequence \u03b8_n(t) adds temporal entropy. Different time windows produce different keys from the same K_nm \u2014 natural key rotation without re-keying.</p>"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#hardware-experiments","title":"Hardware Experiments","text":"Experiment Qubits Status Description <code>bell_test_4q</code> 4 Implemented (v0.6.4) CHSH violation with K_nm ground state on hardware <code>correlator_4q</code> 4 Implemented (v0.6.4) ZZ cross-correlation validates K_ij topology <code>qkd_qber_4q</code> 4 Implemented (v0.6.4) QBER from hardware vs BB84 threshold (&lt; 0.11) <code>correlator_8q</code> 8 Planned Cross-correlation matrix on ibm_fez <code>percolation_16q</code> 16 Planned Full K_nm entanglement map on hardware"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#dependencies-on-existing-modules","title":"Dependencies on Existing Modules","text":"Existing Module Used By Purpose <code>bridge.knm_hamiltonian</code> knm_key, entanglement_qkd K_nm \u2192 H conversion <code>phase.phase_vqe</code> knm_key Ground state preparation <code>qec.control_qec</code> entanglement_qkd Error correction on key circuits <code>mitigation.zne</code> entanglement_qkd Error mitigation for key extraction <code>hardware.runner</code> all experiments IBM hardware execution"},{"location":"QUANTUM_CRYPTO_RESEARCH_BRANCH/#research-timeline","title":"Research Timeline","text":"<p>Phase 1 \u2014 Complete: All 6 crypto modules implemented with full test coverage. <code>knm_key</code>, <code>topology_auth</code>, <code>entanglement_qkd</code>, <code>percolation</code>, <code>hierarchical_keys</code>, <code>noise_analysis</code>.</p> <p>Phase 2 \u2014 Complete: Full SCPN-QKD protocol on simulator. Bell inequality verification, QBER estimation, Devetak-Winter key rates under noise.</p> <p>Phase 3 \u2014 Complete: Entanglement percolation on K_nm graph, hierarchical key derivation from 16-layer SCPN structure.</p> <p>Phase 4 \u2014 In progress: 3 hardware experiment wrappers implemented (v0.6.4). Awaiting March QPU budget for ibm_fez execution. - <code>bell_test_4q</code>: CHSH S-value from hardware counts - <code>correlator_4q</code>: 4x4 connected correlation matrix - <code>qkd_qber_4q</code>: Z-basis and X-basis QBER</p> <p>Phase 5 \u2014 Planned: 8-qubit correlator, 16-qubit percolation on hardware.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#bridge","title":"bridge","text":""},{"location":"api/#knm_hamiltonian","title":"<code>knm_hamiltonian</code>","text":"<p><pre><code>knm_to_hamiltonian(K: np.ndarray, omega: np.ndarray) -&gt; SparsePauliOp\n</code></pre> Convert Knm coupling matrix and natural frequencies to XY Hamiltonian. K[i,j] -&gt; J_ij(X_iX_j + Y_iY_j), omega_i -&gt; h_i * Z_i.</p> <p><pre><code>knm_to_ansatz(K: np.ndarray, reps: int = 2) -&gt; QuantumCircuit\n</code></pre> Build physics-informed ansatz: CZ entanglement only between pairs where K[i,j] &gt; threshold.</p> <pre><code>OMEGA_N_16: np.ndarray  # 16 canonical frequencies (rad/s)\nbuild_knm_paper27() -&gt; np.ndarray  # 16x16 coupling matrix\n</code></pre>"},{"location":"api/#phase_artifact","title":"<code>phase_artifact</code>","text":"<pre><code>LockSignatureArtifact(source_layer, target_layer, plv, mean_lag)\nLayerStateArtifact(R, psi, lock_signatures={})\nUPDEPhaseArtifact(layers, cross_layer_alignment, stability_proxy, regime_id, metadata={})\n</code></pre> <p>Helpers:</p> <pre><code>UPDEPhaseArtifact.to_dict() -&gt; dict\nUPDEPhaseArtifact.to_json(indent=2) -&gt; str\nUPDEPhaseArtifact.from_dict(payload) -&gt; UPDEPhaseArtifact\nUPDEPhaseArtifact.from_json(payload) -&gt; UPDEPhaseArtifact\n</code></pre>"},{"location":"api/#orchestrator_adapter","title":"<code>orchestrator_adapter</code>","text":"<pre><code>PhaseOrchestratorAdapter.from_orchestrator_state(state, metadata=None) -&gt; UPDEPhaseArtifact\nPhaseOrchestratorAdapter.to_orchestrator_payload(artifact) -&gt; dict\nPhaseOrchestratorAdapter.to_scpn_control_telemetry(artifact) -&gt; dict\nPhaseOrchestratorAdapter.build_knm_from_binding_spec(binding_spec, zero_diagonal=False) -&gt; np.ndarray\nPhaseOrchestratorAdapter.build_omega_from_binding_spec(binding_spec, default_omega=1.0) -&gt; np.ndarray\n</code></pre>"},{"location":"api/#control_plasma_knm","title":"<code>control_plasma_knm</code>","text":"<p>Compatibility bridge for <code>scpn-control</code> plasma-native Knm update.</p> <pre><code>build_knm_plasma(mode=\"baseline\", L=8, K_base=0.30, zeta_uniform=0.0, ..., repo_src=None) -&gt; np.ndarray\nbuild_knm_plasma_spec(...) -&gt; dict  # {K, zeta, layer_names}\nbuild_knm_plasma_from_config(R0, a, B0, Ip, n_e, ..., repo_src=None) -&gt; np.ndarray\nplasma_omega(L=8, repo_src=None) -&gt; np.ndarray\n</code></pre> <p>If <code>scpn-control</code> is not importable, these functions raise <code>ImportError</code> with setup guidance.</p>"},{"location":"api/#sc_to_quantum","title":"<code>sc_to_quantum</code>","text":"<pre><code>probability_to_angle(p: float) -&gt; float  # p -&gt; 2*arcsin(sqrt(p))\nangle_to_probability(theta: float) -&gt; float  # theta -&gt; sin^2(theta/2)\nbitstream_to_statevector(bits: np.ndarray) -&gt; np.ndarray\nmeasurement_to_bitstream(counts: dict, length: int) -&gt; np.ndarray\n</code></pre>"},{"location":"api/#spn_to_qcircuit","title":"<code>spn_to_qcircuit</code>","text":"<pre><code>spn_to_circuit(W_in, W_out, thresholds) -&gt; QuantumCircuit\n</code></pre>"},{"location":"api/#qsnn","title":"qsnn","text":""},{"location":"api/#qlifquantumlifneuron","title":"<code>qlif.QuantumLIFNeuron</code>","text":"<pre><code>QuantumLIFNeuron(v_rest=-70.0, v_threshold=-55.0, tau_mem=10.0, dt=1.0, n_shots=100)\n    .step(input_current: float) -&gt; int  # 0 or 1\n    .get_circuit() -&gt; QuantumCircuit\n    .reset()\n</code></pre>"},{"location":"api/#qsynapsequantumsynapse","title":"<code>qsynapse.QuantumSynapse</code>","text":"<pre><code>QuantumSynapse(weight: float, w_min: float = 0.0, w_max: float = 1.0)\n    .apply(circuit, pre_qubit, post_qubit)\n    .effective_weight() -&gt; float\n</code></pre>"},{"location":"api/#qstdpquantumstdp","title":"<code>qstdp.QuantumSTDP</code>","text":"<pre><code>QuantumSTDP(learning_rate: float = 0.01, shift: float = pi/2)\n    .update(synapse, pre_measured, post_measured)\n</code></pre>"},{"location":"api/#qlayerquantumdenselayer","title":"<code>qlayer.QuantumDenseLayer</code>","text":"<pre><code>QuantumDenseLayer(n_neurons: int, n_inputs: int, weights: np.ndarray | None = None, spike_threshold: float = 0.5)\n    .forward(input_values: np.ndarray) -&gt; np.ndarray  # spike array (0/1)\n    .get_weights() -&gt; np.ndarray  # (n_neurons, n_inputs)\n</code></pre>"},{"location":"api/#phase","title":"phase","text":""},{"location":"api/#xy_kuramotoquantumkuramotosolver","title":"<code>xy_kuramoto.QuantumKuramotoSolver</code>","text":"<pre><code>QuantumKuramotoSolver(n_oscillators, K_coupling, omega_natural, backend=None)\n    .build_hamiltonian() -&gt; SparsePauliOp\n    .evolve(time, trotter_steps=1) -&gt; QuantumCircuit\n    .measure_order_parameter(statevector) -&gt; tuple[float, float]  # (R, psi)\n    .run(t_max: float, dt: float, trotter_per_step: int = 5) -&gt; dict  # times, R\n</code></pre>"},{"location":"api/#trotter_updequantumupdesolver","title":"<code>trotter_upde.QuantumUPDESolver</code>","text":"<pre><code>QuantumUPDESolver(n_layers=16, knm=None, omega=None)\n    .build_hamiltonian() -&gt; SparsePauliOp\n    .step(dt, shots=10000) -&gt; dict  # per_layer_R, global_R\n    .run(n_steps, dt, shots=10000) -&gt; dict\n</code></pre>"},{"location":"api/#phase_vqephasevqe","title":"<code>phase_vqe.PhaseVQE</code>","text":"<pre><code>PhaseVQE(K: np.ndarray, omega: np.ndarray, ansatz_reps: int = 2, threshold: float = 0.01)\n    .solve(optimizer=\"COBYLA\", maxiter=200, seed: int | None = None) -&gt; dict\n        # ground_energy, exact_energy, energy_gap, relative_error_pct,\n        # optimal_params, n_evals, n_params, converged\n    .ground_state() -&gt; Statevector | None\n</code></pre>"},{"location":"api/#control","title":"control","text":""},{"location":"api/#qaoa_mpcqaoa_mpc","title":"<code>qaoa_mpc.QAOA_MPC</code>","text":"<pre><code>QAOA_MPC(B_matrix, target_state, horizon, p_layers=2)\n    .build_cost_hamiltonian() -&gt; SparsePauliOp\n    .optimize() -&gt; np.ndarray  # action sequence\n</code></pre>"},{"location":"api/#vqls_gsvqls_gradshafranov","title":"<code>vqls_gs.VQLS_GradShafranov</code>","text":"<pre><code>VQLS_GradShafranov(grid_size=4, source_profile=None)\n    .discretize() -&gt; tuple[np.ndarray, np.ndarray]  # (A, b)\n    .build_ansatz(n_qubits, reps=2) -&gt; QuantumCircuit\n    .solve() -&gt; np.ndarray  # psi profile\n</code></pre>"},{"location":"api/#qpetriquantumpetrinet","title":"<code>qpetri.QuantumPetriNet</code>","text":"<pre><code>QuantumPetriNet(n_places, n_transitions, W_in, W_out, thresholds=None)\n    .encode_marking(marking) -&gt; QuantumCircuit\n    .step(marking, shots=1000) -&gt; np.ndarray  # new marking\n</code></pre>"},{"location":"api/#q_disruptionquantumdisruptionclassifier","title":"<code>q_disruption.QuantumDisruptionClassifier</code>","text":"<pre><code>QuantumDisruptionClassifier(n_features=11, n_layers=3)\n    .predict(features: np.ndarray) -&gt; float  # risk score [0, 1]\n    .train(X, y, epochs=10, lr=0.01)\n</code></pre>"},{"location":"api/#qec","title":"qec","text":""},{"location":"api/#control_qeccontrolqec","title":"<code>control_qec.ControlQEC</code>","text":"<pre><code>ControlQEC(distance=3)\n    .protect_signal(circuit) -&gt; QuantumCircuit\n    .decode_syndrome(syndrome) -&gt; np.ndarray  # correction\n</code></pre>"},{"location":"api/#mitigation","title":"mitigation","text":""},{"location":"api/#zne","title":"<code>zne</code>","text":"<pre><code>@dataclass\nclass ZNEResult:\n    noise_scales: list[int]\n    expectation_values: list[float]\n    zero_noise_estimate: float\n    fit_residual: float\n</code></pre> <p><pre><code>gate_fold_circuit(circuit: QuantumCircuit, scale: int) -&gt; QuantumCircuit\n</code></pre> Global unitary folding: G \u2192 G (G\u2020G)^((scale-1)/2). <code>scale</code> must be an odd positive integer. Measurements are stripped before folding and re-appended.</p> <p><pre><code>zne_extrapolate(noise_scales: list[int], expectation_values: list[float], order: int = 1) -&gt; ZNEResult\n</code></pre> Richardson extrapolation to zero noise. <code>order</code> controls polynomial degree (1=linear, 2=quadratic).</p>"},{"location":"api/#dd","title":"<code>dd</code>","text":"<pre><code>class DDSequence(Enum):\n    XY4 = \"XY4\"\n    X2 = \"X2\"\n    CPMG = \"CPMG\"\n</code></pre> <p><pre><code>insert_dd_sequence(circuit: QuantumCircuit, idle_qubits: list[int], sequence: DDSequence = DDSequence.XY4) -&gt; QuantumCircuit\n</code></pre> Insert DD pulses on <code>idle_qubits</code> after existing gates. For transpiler-level insertion, use <code>HardwareRunner.transpile_with_dd()</code>.</p>"},{"location":"api/#hardware","title":"hardware","text":""},{"location":"api/#runner","title":"<code>runner</code>","text":"<pre><code>run_experiment(experiment_name, backend_name=\"ibm_fez\", shots=10000, **kwargs) -&gt; dict\n</code></pre>"},{"location":"api/#experiments","title":"<code>experiments</code>","text":"<pre><code>build_kuramoto_circuits(n_qubits, t_max, dt, trotter_reps=1) -&gt; list[QuantumCircuit]\nbuild_vqe_circuit(n_qubits, params, knm=None) -&gt; QuantumCircuit\nbuild_qaoa_circuit(cost_hamiltonian, p_layers, params) -&gt; QuantumCircuit\n</code></pre>"},{"location":"api/#classical","title":"<code>classical</code>","text":"<pre><code>classical_kuramoto_reference(n_osc, t_max, dt, K=None, omega=None, theta0=None) -&gt; dict\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#module-dependency-graph","title":"Module Dependency Graph","text":"<pre><code>bridge/\n\u251c\u2500\u2500 knm_hamiltonian.py   (standalone - canonical Knm data)\n\u251c\u2500\u2500 control_plasma_knm.py (optional bridge to scpn-control plasma Knm builders)\n\u251c\u2500\u2500 phase_artifact.py    (shared UPDE phase artifact schema)\n\u251c\u2500\u2500 orchestrator_adapter.py (phase-orchestrator payload adapter)\n\u251c\u2500\u2500 sc_to_quantum.py     (standalone - angle/probability conversion)\n\u2514\u2500\u2500 spn_to_qcircuit.py   (uses sc_to_quantum)\n\nqsnn/\n\u251c\u2500\u2500 qlif.py              (standalone)\n\u251c\u2500\u2500 qsynapse.py          (standalone)\n\u251c\u2500\u2500 qstdp.py             (uses qsynapse)\n\u2514\u2500\u2500 qlayer.py            (uses qlif, qsynapse)\n\nphase/\n\u251c\u2500\u2500 xy_kuramoto.py       (uses knm_hamiltonian)\n\u251c\u2500\u2500 trotter_upde.py      (uses knm_hamiltonian)\n\u2514\u2500\u2500 phase_vqe.py         (uses knm_hamiltonian)\n\ncontrol/\n\u251c\u2500\u2500 qaoa_mpc.py          (uses knm_hamiltonian)\n\u251c\u2500\u2500 vqls_gs.py           (standalone)\n\u251c\u2500\u2500 qpetri.py            (uses spn_to_qcircuit)\n\u2514\u2500\u2500 q_disruption.py      (uses sc_to_quantum)\n\nqec/\n\u2514\u2500\u2500 control_qec.py       (standalone)\n\nhardware/\n\u251c\u2500\u2500 runner.py            (uses xy_kuramoto, phase_vqe, qaoa_mpc)\n\u251c\u2500\u2500 experiments.py       (uses knm_hamiltonian)\n\u2514\u2500\u2500 classical.py         (standalone - numpy ODE reference)\n</code></pre>"},{"location":"architecture/#classical-to-quantum-mapping","title":"Classical-to-Quantum Mapping","text":"<p>Each module maps a classical SCPN computation to its quantum analog:</p> Classical (SCPN) Quantum (this repo) Mapping Stochastic LIF membrane potential Ry(theta) rotation angle theta = pi * (v - v_rest) / (v_threshold - v_rest) Bitstream AND-gate synapse CRy(theta_w) controlled rotation P(out) = P(pre) * sin^2(theta_w/2) STDP correlation learning Parameter-shift gradient rule dw = lr * pre * d/d(theta) Kuramoto ODE (dtheta/dt) XY Hamiltonian Trotter evolution H = -K_ij(XX + YY) - omega_i Z_i 16-layer UPDE coupling 16-qubit spin chain Knm -&gt; J_ij entangling gates MPC quadratic cost QAOA Ising Hamiltonian Grad-Shafranov PDE VQLS linear system Laplacian A, source b -&gt; A SPN token probability Qubit amplitude p -&gt; amplitude encoding Disruption feature vector Amplitude-encoded state 11-D -&gt; 16-D zero-padded"},{"location":"architecture/#hardware-execution-model","title":"Hardware Execution Model","text":"<pre><code>Classical optimizer loop (COBYLA/SPSA)\n  |\n  v\nBuild QuantumCircuit (parameterized)\n  |\n  v\nTranspile to native gates (CZ, RZ, SX, X on Heron r2)\n  |\n  v\nSubmit via qiskit-ibm-runtime SamplerV2\n  |\n  v\nParse bit-string counts -&gt; expectation values\n  |\n  v\nCompute order parameter R from &lt;X&gt;, &lt;Y&gt;, &lt;Z&gt;\n</code></pre> <p>Circuit depth after transpilation determines which decoherence regime applies: - depth &lt; 150: publishable accuracy (&lt; 10% error) - depth 150-400: usable with error mitigation - depth &gt; 400: qualitative results only</p>"},{"location":"architecture/#data-flow-knm-hamiltonian-circuit-measurement-r","title":"Data Flow: Knm -&gt; Hamiltonian -&gt; Circuit -&gt; Measurement -&gt; R","text":"<pre><code>from scpn_quantum_control.bridge.knm_hamiltonian import (\n    OMEGA_N_16, build_knm_paper27, knm_to_hamiltonian,\n)\nfrom scpn_quantum_control.phase.xy_kuramoto import QuantumKuramotoSolver\n\nK = build_knm_paper27()\nomega = OMEGA_N_16[:4]\nsolver = QuantumKuramotoSolver(4, K[:4, :4], omega)\nresult = solver.run(t_max=0.4, dt=0.1)\n# result[\"R_trajectory\"] -&gt; [0.80, 0.78, 0.76, 0.73]\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to scpn-quantum-control are documented here. Format follows Keep a Changelog.</p> <p>Full detailed changelog: CHANGELOG.md</p>"},{"location":"changelog/#070-2026-03-02","title":"[0.7.0] - 2026-03-02","text":"<p>Packaging, RNG hygiene, CI, exports hardening.</p> <ul> <li>Fix crypto <code>__all__</code> (callable symbols, not module names)</li> <li>PEP 561 <code>py.typed</code> marker</li> <li>Seeded RNG in <code>QuantumDenseLayer</code>, <code>inf</code> \u2192 <code>nan</code> in PhaseVQE</li> <li>Named constants in percolation, pip cache in CI, dependency upper bounds</li> <li>456 tests, 99%+ coverage</li> </ul>"},{"location":"changelog/#064-2026-03-01","title":"[0.6.4] - 2026-03-01","text":"<p>Docs/metadata hardening.</p> <ul> <li>Fix stale test counts (411/424 \u2192 442) in docs pages</li> <li>Fix header generator version string (v0.5.1 \u2192 v0.6.3)</li> <li>Complete README architecture tree (3 missing files)</li> <li>Add scpn-phase-orchestrator to Related Repositories</li> <li>Update SECURITY.md supported versions (0.6.x)</li> <li>Add pip ecosystem to dependabot</li> <li>Version bump 0.6.2 \u2192 0.6.4</li> </ul>"},{"location":"changelog/#063-2026-03-01","title":"[0.6.3] - 2026-03-01","text":"<p>Coverage gate, mitigation API docs, notebook table.</p> <ul> <li>Coverage gate in CI, mitigation API docs, notebook summary table, ruff fix</li> <li>Test count: 424 \u2192 442</li> </ul>"},{"location":"changelog/#062-2026-03-01","title":"[0.6.2] - 2026-03-01","text":"<p>Notebook fixes + Knm heatmap figure.</p> <ul> <li>Notebooks 01/03/04: <code>classical_kuramoto_ode</code> \u2192 <code>classical_kuramoto_reference</code></li> <li>Notebook 03: ZNE scales [1,2,3,4,5] \u2192 [1,3,5,7,9] (odd required by gate_fold_circuit)</li> <li>Notebook 04: rewrite to 8-qubit Trotter + 16-layer classical (16-qubit statevector intractable on laptop)</li> <li><code>figures/generate_knm_heatmap.py</code> + <code>figures/knm_heatmap.png</code> (16\u00d716 K_nm coupling matrix)</li> <li>Knm heatmap figure in README with annotated calibration anchors</li> <li>All 4 notebooks executed with embedded outputs</li> <li>Remove misplaced docs/SESSION_LOG and docs/HANDOVER (duplicates of .coordination/)</li> </ul>"},{"location":"changelog/#061-2026-03-01","title":"[0.6.1] - 2026-03-01","text":"<p>mypy + Zenodo metadata fixes.</p> <ul> <li>mypy errors in bridge module: remove FloatArray type alias (incompatible with Python 3.9), fix Path(None) in control_plasma_knm.py</li> <li>Zenodo metadata enriched (.zenodo.json, CITATION.cff)</li> </ul>"},{"location":"changelog/#060-2026-03-01","title":"[0.6.0] - 2026-03-01","text":"<p>Hardening + high-level API.</p> <ul> <li>Input validation guards on all public API constructors \u2014 prevents div-by-zero in qlif, qsynapse, qstdp, qaoa_mpc, classical_kuramoto_reference; bounds-checks on bell_inequality_test, best_entanglement_path</li> <li><code>PhaseVQE.solve()</code> now returns <code>exact_energy</code>, <code>energy_gap</code>, <code>relative_error_pct</code>, <code>n_params</code></li> <li>Notebook 02 fixed to use enriched solve() dict</li> <li>13 validation tests (424 total)</li> </ul>"},{"location":"changelog/#051-2026-03-01","title":"[0.5.1] - 2026-03-01","text":"<p>Version alignment. Fixes <code>__version__</code> mismatch from v0.5.0 tag timing.</p>"},{"location":"changelog/#050-2026-03-01","title":"[0.5.0] - 2026-03-01","text":"<p>Quantum cryptography hardware experiments.</p> <ul> <li>3 new crypto experiments: Bell test (CHSH), ZZ correlator, QKD QBER</li> <li><code>devetak_winter_rate()</code> key rate computation</li> <li>20 experiments in registry, 411 tests</li> </ul>"},{"location":"changelog/#040-2026-02-28","title":"[0.4.0] - 2026-02-28","text":"<p>Docs, notebooks, and test depth.</p> <ul> <li>GitHub Pages MkDocs Material site (7 pages, auto-deploy)</li> <li>4 Jupyter notebooks: Kuramoto XY, VQE ground state, ZNE mitigation, UPDE-16</li> <li>10 new hardware experiments (noise baseline, 8-osc ZNE, Trotter order-2, etc.)</li> <li>14 property-based tests (hypothesis), 8 edge-case tests, 13 coverage-gap tests</li> <li>4 integration tests, 7 regression tests</li> <li>Test count: 208 \u2192 254</li> </ul>"},{"location":"changelog/#030-2026-02-28","title":"[0.3.0] - 2026-02-28","text":"<p>README rewrite and validation hardening.</p> <ul> <li>Motivating abstract: SCPN\u2192XY isomorphism, Kuramoto-to-Hamiltonian derivation, 4 figures</li> <li>mypy expanded to 30 source files (8 module paths), zero errors</li> <li>VALIDATION.md test count 88 \u2192 199</li> <li>Paper 27 citation, examples/README.md walkthrough</li> </ul>"},{"location":"changelog/#020027-2026-02-28","title":"[0.2.0\u20130.2.7] - 2026-02-28","text":"<p>Error mitigation, QEC fixes, classical references.</p> <ul> <li>ZNE (unitary folding + Richardson), DD (XY4, X2) for idle qubits</li> <li>Heron r2 noise model factory</li> <li>MWPM decoder: 3 bug fixes (dual edges, seam-crossing, d=5 &gt; d=3)</li> <li>Classical endianness fix verified against Statevector to 1e-6</li> <li>QAOA Ising encoding fix, Petri net multi-input AND gating</li> <li>Second-order Trotter, energy tracking</li> <li>20 classical reference tests, parametrized quantum-vs-classical validation</li> <li>Test count: 88 \u2192 208</li> </ul>"},{"location":"changelog/#010-2026-02-28","title":"[0.1.0] - 2026-02-28","text":"<p>Initial release.</p> <ul> <li>qsnn/: Quantum LIF neuron, CRy synapse, parameter-shift STDP, dense layer</li> <li>phase/: Kuramoto XY solver, 16-layer Trotter UPDE, VQE ground state</li> <li>control/: QAOA-MPC, VQLS Grad-Shafranov, quantum Petri net, disruption classifier</li> <li>bridge/: Knm\u2192Hamiltonian compiler, SPN\u2192circuit, bitstream\u2192rotation</li> <li>qec/: Toric surface code + MWPM decoder (Knm-weighted)</li> <li>hardware/: IBM Quantum runner for ibm_fez Heron r2</li> <li>88 tests, 4 examples, 19 hardware result files</li> <li>Hardware: VQE 0.05% error, 12-point decoherence curve, 16-layer UPDE snapshot</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>See CONTRIBUTING.md for the full contribution guide.</p>"},{"location":"contributing/#quick-setup","title":"Quick setup","text":"<pre><code>git clone https://github.com/anulum/scpn-quantum-control.git\ncd scpn-quantum-control\npip install -e \".[dev]\"\npytest tests/ -x -q\n</code></pre>"},{"location":"contributing/#code-quality-gates","title":"Code quality gates","text":"<p>All PRs must pass:</p> <pre><code>ruff check src/ tests/       # zero errors\nruff format --check src/ tests/  # zero diffs\npython -m mypy src/           # zero errors\npytest tests/ -x -q           # 456 tests pass\n</code></pre>"},{"location":"contributing/#anti-slop-policy","title":"Anti-slop policy","text":"<p>This project enforces the anti-slop code policy from <code>CLAUDE.md</code>. No narration comments, no buzzword naming, no placeholder values without tracked issues, no trivial wrappers.</p>"},{"location":"equations/","title":"Key Equations","text":""},{"location":"equations/#scpn-overview","title":"SCPN Overview","text":"<p>The Self-Consistent Phenomenological Network (SCPN) is a theoretical framework modeling hierarchical dynamics as 16 coupled oscillators. Each layer n has a natural frequency omega_n and interacts with other layers through a coupling matrix K_nm. The master equation governing all 16 layers is the Unified Phase Dynamics Equation (UPDE), which takes the form of a coupled Kuramoto system with layer-specific forcing terms.</p> <p>Reference: M. Sotek, Self-Consistent Phenomenological Network: Layer Dynamics and Coupling Structure, Working Paper 27 (2025). Manuscript in preparation.</p>"},{"location":"equations/#kuramoto-xy-hamiltonian","title":"Kuramoto -&gt; XY Hamiltonian","text":"<p>Classical Kuramoto (the UPDE core): <pre><code>d(theta_i)/dt = omega_i + sum_j K_ij sin(theta_j - theta_i)\n</code></pre></p> <p>Quantum XY Hamiltonian: <pre><code>H = -sum_{i&lt;j} K_ij (X_i X_j + Y_i Y_j) - sum_i omega_i Z_i\n</code></pre></p> <p>Time evolution via Lie-Trotter decomposition: <pre><code>U(t) = exp(-iHt) ~ [exp(-iH_zz dt) exp(-iH_z dt)]^(t/dt)\n</code></pre></p> <p>Order parameter from qubit expectations: <pre><code>R = (1/N) |sum_i (&lt;X_i&gt; + i &lt;Y_i&gt;)|\n</code></pre></p>"},{"location":"equations/#knm-canonical-parameters","title":"Knm Canonical Parameters","text":"<p>Natural frequencies (16 layers, Paper 27 Table 1): <pre><code>omega = [1.329, 1.255, 1.183, 1.114, 1.048, 0.985, 1.068, 1.148,\n         1.095, 1.028, 0.974, 0.929, 1.012, 0.962, 1.042, 0.991]\n</code></pre></p> <p>Coupling matrix (Paper 27, Eq. 3): <pre><code>K_nm = K_base * exp(-alpha * |n - m|)  # K_base=0.45, alpha=0.3\n</code></pre></p> <p>Calibration anchors: K[1,2]=0.302, K[2,3]=0.201, K[3,4]=0.252, K[4,5]=0.154. Cross-hierarchy boosts: L1-L16=0.05, L5-L7=0.15.</p>"},{"location":"equations/#upde-unified-phase-dynamics-equation","title":"UPDE (Unified Phase Dynamics Equation)","text":"<p>The UPDE extends the Kuramoto model with layer-specific terms: <pre><code>d(theta_n)/dt = omega_n + sum_m K_nm sin(theta_m - theta_n) + F_n(theta, t)\n</code></pre></p> <p>where F_n captures layer-specific forcing (external input, feedback loops). In the quantum mapping, F_n corresponds to single-qubit Z rotations beyond the natural frequency term.</p>"},{"location":"equations/#quantum-lif-neuron","title":"Quantum LIF Neuron","text":"<p>Membrane dynamics (classical): <pre><code>v(t+1) = v(t) - (dt/tau)(v(t) - v_rest) + R*I*dt\n</code></pre></p> <p>Rotation angle encoding: <pre><code>theta = pi * clip((v - v_rest) / (v_threshold - v_rest), 0, 1)\n</code></pre></p> <p>Spike probability: <pre><code>P(spike) = sin^2(theta/2)\n</code></pre></p>"},{"location":"equations/#quantum-synapse-cry","title":"Quantum Synapse (CRy)","text":"<p>Weight-to-angle: <pre><code>theta_w = pi * (w - w_min) / (w_max - w_min)\n</code></pre></p> <p>Effective transmission probability: <pre><code>P(post|pre=1) = sin^2(theta_w / 2)\n</code></pre></p>"},{"location":"equations/#parameter-shift-stdp","title":"Parameter-Shift STDP","text":"<p>Gradient of expectation: <pre><code>d&lt;Z&gt;/d(theta) = [&lt;Z&gt;(theta + pi/2) - &lt;Z&gt;(theta - pi/2)] / 2\n</code></pre></p> <p>Weight update: <pre><code>delta_w = lr * pre_spike * d&lt;Z_post&gt;/d(theta_w)\n</code></pre></p>"},{"location":"equations/#qaoa-cost-hamiltonian","title":"QAOA Cost Hamiltonian","text":"<p>MPC quadratic cost -&gt; Ising: <pre><code>C = sum_t ||B*u(t) - target||^2\n  = sum_{i,j} J_ij Z_i Z_j + sum_i h_i Z_i + const\n</code></pre></p> <p>QAOA circuit: <pre><code>|gamma, beta&gt; = prod_p [exp(-i beta_p H_mixer) exp(-i gamma_p H_cost)] |+&gt;^n\n</code></pre></p>"},{"location":"equations/#vqls-cost-function","title":"VQLS Cost Function","text":"<p>For linear system Ax = b: <pre><code>C = 1 - |&lt;b|A|x&gt;|^2 / &lt;x|A'A|x&gt;\n</code></pre></p> <p>where |x&gt; = U(theta)|0&gt; is a variational ansatz.</p>"},{"location":"hardware_guide/","title":"Hardware Execution Guide","text":""},{"location":"hardware_guide/#prerequisites","title":"Prerequisites","text":"<ol> <li>IBM Quantum account: https://quantum.ibm.com</li> <li>Credentials configured:    <pre><code>export QISKIT_IBM_TOKEN=\"your-token-here\"\n# or save to ~/.qiskit/qiskit-ibm.json\n</code></pre></li> <li>Install IBM runtime:    <pre><code>pip install -e \".[ibm]\"\n</code></pre></li> </ol>"},{"location":"hardware_guide/#qpu-budget","title":"QPU Budget","text":"<p>Free tier: 10 minutes/month on ibm_fez (Heron r2, 156 qubits).</p> <p>Typical costs: | Experiment | Circuits | Shots | QPU seconds | |------------|----------|-------|-------------| | kuramoto_4osc (1 step) | 3 | 10k | ~15 | | vqe_4q (100 COBYLA iter) | ~100 | 10k | ~15 | | qaoa_mpc (p=1, COBYLA) | ~30 | 10k | ~100 | | upde_16 snapshot | 3 | 20k | ~60 |</p>"},{"location":"hardware_guide/#running-experiments","title":"Running Experiments","text":"<pre><code># Single experiment\npython run_hardware.py --experiment kuramoto --qubits 4 --shots 10000\n\n# All experiments\npython run_hardware.py --all\n</code></pre> <p>Results are saved to <code>results/hw_&lt;name&gt;.json</code>.</p>"},{"location":"hardware_guide/#decoherence-reference","title":"Decoherence Reference","text":"<p>Use this table to estimate whether your circuit will produce meaningful results:</p> Depth range Expected error Recommendation &lt; 50 &lt; 5% Publishable as-is 50-150 5-15% Publishable with error bars 150-250 15-25% Apply ZNE mitigation 250-400 25-40% Qualitative trends only &gt; 400 &gt; 40% Do not trust individual values"},{"location":"hardware_guide/#native-gate-set-heron-r2","title":"Native Gate Set (Heron r2)","text":"Gate Description CZ Two-qubit entangling (native) RZ(theta) Z rotation SX sqrt(X) X Pauli-X (bit flip) ID Identity (delay) <p>Transpilation from Qiskit standard gates to native gates increases depth. Typical expansion: 1 CNOT -&gt; 2 SX + 1 CZ + RZ gates.</p>"},{"location":"hardware_guide/#interpreting-results","title":"Interpreting Results","text":"<p>Order parameter R is computed from qubit expectation values:</p> <pre><code>R = (1/N) * |sum_i (X_i + i*Y_i)|\n</code></pre> <p>where X_i = 2*P(|0&gt;) - 1 for X-basis measurement, etc.</p> <p>Compare <code>hw_R</code> against <code>exact_R</code> (from AerSimulator statevector) to quantify hardware error.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#from-pypi","title":"From PyPI","text":"<pre><code>pip install scpn-quantum-control\n</code></pre>"},{"location":"installation/#from-source-development","title":"From source (development)","text":"<pre><code>git clone https://github.com/anulum/scpn-quantum-control.git\ncd scpn-quantum-control\npip install -e \".[dev]\"\n</code></pre> <p>This installs pytest, ruff, and pytest-cov for development.</p>"},{"location":"installation/#optional-dependencies","title":"Optional dependencies","text":"<pre><code># Visualization (matplotlib)\npip install -e \".[viz]\"\n\n# IBM Quantum hardware execution\npip install -e \".[ibm]\"\n\n# Everything\npip install -e \".[dev,viz,ibm]\"\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> <li>Qiskit 1.0+</li> <li>qiskit-aer 0.14+</li> <li>NumPy 1.24+</li> <li>SciPy 1.10+</li> <li>NetworkX 3.0+</li> </ul>"},{"location":"installation/#verify-installation","title":"Verify installation","text":"<pre><code>python -c \"import scpn_quantum_control; print('OK')\"\npytest tests/ -x -q  # 456 tests should pass\n</code></pre>"},{"location":"installation/#ibm-quantum-setup-optional","title":"IBM Quantum setup (optional)","text":"<p>Only needed for real hardware execution. See Hardware Guide.</p> <pre><code>from scpn_quantum_control.hardware import HardwareRunner\n\n# One-time: save your API token\nHardwareRunner.save_token(\"your-ibm-quantum-token\")\n\n# Connect to hardware\nrunner = HardwareRunner()\nrunner.connect()\nprint(f\"Backend: {runner.backend_name}\")\n</code></pre> <p>Free tier: 10 minutes QPU time per month on ibm_fez (Heron r2, 156 qubits).</p>"},{"location":"mitigation_api/","title":"Mitigation API Reference","text":"<p>Error mitigation modules for noise reduction on NISQ hardware.</p>"},{"location":"mitigation_api/#zero-noise-extrapolation-mitigationzne","title":"Zero-Noise Extrapolation (<code>mitigation.zne</code>)","text":""},{"location":"mitigation_api/#zneresult","title":"<code>ZNEResult</code>","text":"<pre><code>@dataclass\nclass ZNEResult:\n    noise_scales: list[int]\n    expectation_values: list[float]\n    zero_noise_estimate: float\n    fit_residual: float\n</code></pre> <p>Fields:</p> Field Type Description <code>noise_scales</code> <code>list[int]</code> Odd integers used as folding factors (e.g. <code>[1, 3, 5]</code>) <code>expectation_values</code> <code>list[float]</code> Measured expectation at each noise scale <code>zero_noise_estimate</code> <code>float</code> Richardson-extrapolated value at zero noise <code>fit_residual</code> <code>float</code> L2 residual of the polynomial fit"},{"location":"mitigation_api/#gate_fold_circuit","title":"<code>gate_fold_circuit</code>","text":"<pre><code>gate_fold_circuit(circuit: QuantumCircuit, scale: int) -&gt; QuantumCircuit\n</code></pre> <p>Global unitary folding: <code>G \u2192 G (G\u2020G)^((scale-1)/2)</code>.</p> <p>Parameters:</p> Param Type Description <code>circuit</code> <code>QuantumCircuit</code> Input circuit (measurements stripped before folding, re-appended) <code>scale</code> <code>int</code> Odd positive integer folding factor (1 = no folding, 3 = one fold, etc.) <p>Returns: New <code>QuantumCircuit</code> with folded unitaries and measurements re-appended.</p> <p>Raises: <code>ValueError</code> if <code>scale</code> is not a positive odd integer.</p>"},{"location":"mitigation_api/#zne_extrapolate","title":"<code>zne_extrapolate</code>","text":"<pre><code>zne_extrapolate(noise_scales: list[int], expectation_values: list[float], order: int = 1) -&gt; ZNEResult\n</code></pre> <p>Richardson extrapolation to zero noise.</p> <p>Parameters:</p> Param Type Default Description <code>noise_scales</code> <code>list[int]</code> \u2014 Noise amplification factors (must match <code>expectation_values</code> length) <code>expectation_values</code> <code>list[float]</code> \u2014 Measured expectations at each scale <code>order</code> <code>int</code> <code>1</code> Polynomial degree: 1 = linear, 2 = quadratic <p>Returns: <code>ZNEResult</code> with extrapolated zero-noise estimate and fit residual.</p>"},{"location":"mitigation_api/#dynamical-decoupling-mitigationdd","title":"Dynamical Decoupling (<code>mitigation.dd</code>)","text":""},{"location":"mitigation_api/#ddsequence","title":"<code>DDSequence</code>","text":"<pre><code>class DDSequence(Enum):\n    XY4 = \"XY4\"\n    X2 = \"X2\"\n    CPMG = \"CPMG\"\n</code></pre> <p>Supported pulse sequences:</p> Sequence Gates Reference <code>XY4</code> X-Y-X-Y Viola et al. 1999 <code>X2</code> X-X Spin echo <code>CPMG</code> Y-Y Carr-Purcell-Meiboom-Gill"},{"location":"mitigation_api/#insert_dd_sequence","title":"<code>insert_dd_sequence</code>","text":"<pre><code>insert_dd_sequence(\n    circuit: QuantumCircuit,\n    idle_qubits: list[int],\n    sequence: DDSequence = DDSequence.XY4,\n) -&gt; QuantumCircuit\n</code></pre> <p>Insert DD pulses on idle qubits after existing gates.</p> <p>Parameters:</p> Param Type Default Description <code>circuit</code> <code>QuantumCircuit</code> \u2014 Circuit with idle periods to fill <code>idle_qubits</code> <code>list[int]</code> \u2014 Qubit indices to apply DD pulses <code>sequence</code> <code>DDSequence</code> <code>DDSequence.XY4</code> Pulse sequence type <p>Returns: New <code>QuantumCircuit</code> with DD pulses inserted.</p> <p>For transpiler-level insertion on hardware, use <code>HardwareRunner.transpile_with_dd()</code> which integrates with Qiskit's <code>PadDynamicalDecoupling</code> pass.</p>"},{"location":"notebooks/","title":"Notebooks","text":"<p>Interactive Jupyter notebooks covering the core workflows. Run locally (<code>pip install -e \".[dev]\"</code>) or on Google Colab.</p> Notebook Description Key Outputs Prerequisites 01_kuramoto_xy_dynamics Builds the XY Hamiltonian from a 4-oscillator Knm matrix, runs Trotter evolution, and compares quantum R(t) against the classical ODE. Extends to 8 oscillators. R(t) trajectory plot, quantum-vs-classical overlay, 8-osc scaling None 02_vqe_ground_state Solves the Kuramoto-XY ground state via VQE with three ansatz variants (Knm-informed, TwoLocal, EfficientSU2). Compares 4-qubit and 8-qubit scaling. Energy convergence curves, ansatz comparison table, optimal parameters None 03_error_mitigation Demonstrates ZNE on a noisy Heron r2 simulator: unitary folding at scales 1/3/5, Richardson extrapolation, and higher-order polynomial fit. Extrapolation plot, ZNEResult dataclass, mitigated vs raw error None 04_upde_16_layer Simulates the full 16-layer SCPN UPDE as a 16-qubit spin chain. Per-layer coherence analysis and time evolution over multiple Trotter steps. Per-layer R bar chart, time evolution heatmap, global R trajectory None <p>All notebooks run on the local AerSimulator. No IBM credentials needed.</p>"},{"location":"notebooks/#running-locally","title":"Running locally","text":"<pre><code>pip install -e \".[dev]\"\njupyter notebook notebooks/\n</code></pre>"},{"location":"orchestrator_integration/","title":"Orchestrator Integration","text":"<p>This page documents how <code>scpn-quantum-control</code> now interoperates with <code>scpn-phase-orchestrator</code> and fusion-specific Kuramoto/UPDE specifications.</p>"},{"location":"orchestrator_integration/#why-this-exists","title":"Why this exists","text":"<p>Fusion control needs cause-specific phase semantics:</p> <ul> <li>oscillator definitions (what each phase means physically)</li> <li>hierarchy layers</li> <li>coupling (<code>Knm</code>), phase lags (<code>alpha</code>), drivers (<code>zeta</code>, <code>Psi</code>)</li> <li>objectives (<code>R_good</code>, <code>R_bad</code>)</li> <li>boundary and regime behavior</li> </ul> <p>Those semantics are owned by the orchestrator/domain spec layer. <code>scpn-quantum-control</code> should execute quantum mappings from that spec, not redefine the semantics independently.</p>"},{"location":"orchestrator_integration/#non-collision-policy-with-scpn-control","title":"Non-collision policy (with <code>scpn-control</code>)","text":"<p><code>scpn-control</code> can continue evolving its plasma Knm builder independently. This repo does not override it.</p> <p>Instead, we added:</p> <ul> <li>a shared phase artifact schema (<code>UPDEPhaseArtifact</code>)</li> <li>an orchestrator adapter (<code>PhaseOrchestratorAdapter</code>)</li> <li>parity tests that detect drift between implementations</li> </ul> <p>This keeps ownership boundaries clear while enforcing consistency.</p>"},{"location":"orchestrator_integration/#scpn-control-plasma-knm-compatibility","title":"scpn-control plasma Knm compatibility","text":"<p><code>scpn-control</code> now provides a plasma-native Knm builder:</p> <ul> <li><code>build_knm_plasma(...)</code></li> <li><code>build_knm_plasma_from_config(...)</code></li> <li><code>plasma_omega(...)</code></li> </ul> <p><code>scpn-quantum-control</code> integrates this through <code>scpn_quantum_control.bridge.control_plasma_knm</code> with lazy imports, so we can consume the latest plasma coupling logic without taking a hard runtime dependency.</p> <p>Use <code>repo_src</code> when working in a multi-repo workspace:</p> <pre><code>from pathlib import Path\nfrom scpn_quantum_control.bridge import build_knm_plasma, plasma_omega\n\nrepo_src = Path(\\\"../scpn-control/src\\\")\nK = build_knm_plasma(mode=\\\"ntm\\\", repo_src=repo_src)\nomega = plasma_omega(L=8, repo_src=repo_src)\n</code></pre>"},{"location":"orchestrator_integration/#new-bridge-components","title":"New bridge components","text":""},{"location":"orchestrator_integration/#1-shared-phase-artifact-schema","title":"1. Shared phase artifact schema","text":"<p>Module: <code>scpn_quantum_control.bridge.phase_artifact</code></p> <p>Key types:</p> <ul> <li><code>LockSignatureArtifact</code></li> <li><code>LayerStateArtifact</code></li> <li><code>UPDEPhaseArtifact</code></li> </ul> <p>These support validated <code>dict</code>/JSON roundtrips for backend-independent phase state exchange.</p>"},{"location":"orchestrator_integration/#2-orchestrator-adapter","title":"2. Orchestrator adapter","text":"<p>Module: <code>scpn_quantum_control.bridge.orchestrator_adapter</code></p> <p>Key entry points:</p> <ul> <li><code>from_orchestrator_state(state)</code>:   converts orchestrator payloads (dataclass or dict) into <code>UPDEPhaseArtifact</code></li> <li><code>to_scpn_control_telemetry(artifact)</code>:   exports control-compatible telemetry layout</li> <li><code>build_knm_from_binding_spec(binding_spec)</code>:   derives <code>Knm</code> from orchestrator coupling contract</li> <li><code>build_omega_from_binding_spec(binding_spec)</code>:   derives per-oscillator <code>omega</code></li> </ul>"},{"location":"orchestrator_integration/#fusion-defined-spec-quantum-execution-flow","title":"Fusion-defined spec -&gt; quantum execution flow","text":"<ol> <li>Define/validate fusion binding spec in <code>scpn-phase-orchestrator</code>.</li> <li>Build <code>Knm</code>/<code>omega</code> from that spec using adapter functions.</li> <li>Compile <code>Knm</code> to XY Hamiltonian via <code>knm_to_hamiltonian</code>.</li> <li>Run quantum phase solver / VQE / hardware lanes.</li> <li>Persist phase state as <code>UPDEPhaseArtifact</code>.</li> </ol>"},{"location":"orchestrator_integration/#example","title":"Example","text":"<pre><code>from scpn_quantum_control.bridge import (\n    PhaseOrchestratorAdapter,\n    knm_to_hamiltonian,\n)\n\nbinding_spec = {\n    \"layers\": [\n        {\"name\": \"macro\", \"index\": 0, \"oscillator_ids\": [\"m0\", \"m1\"], \"natural_frequency\": 1.4},\n        {\"name\": \"edge\", \"index\": 1, \"oscillator_ids\": [\"e0\"]},\n    ],\n    \"coupling\": {\"base_strength\": 0.45, \"decay_alpha\": 0.3, \"templates\": {}},\n}\n\nK = PhaseOrchestratorAdapter.build_knm_from_binding_spec(binding_spec)\nomega = PhaseOrchestratorAdapter.build_omega_from_binding_spec(binding_spec, default_omega=1.0)\nH = knm_to_hamiltonian(K, omega)\n</code></pre>"},{"location":"orchestrator_integration/#drift-guardrails","title":"Drift guardrails","text":"<p>Parity tests now cover:</p> <ul> <li>quantum Knm parity vs <code>scpn-control</code> Paper-27 builder</li> <li>quantum plasma Knm parity vs <code>scpn-control</code> plasma-native builders</li> <li>orchestrator exponential-decay kernel parity</li> <li>quantum base-kernel invariance on untouched edges</li> </ul> <p>See: - <code>tests/test_knm_parity.py</code> - <code>tests/test_phase_artifact.py</code> - <code>tests/test_orchestrator_adapter.py</code></p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>All examples run on the local AerSimulator \u2014 no IBM credentials needed.</p>"},{"location":"quickstart/#1-kuramoto-dynamics-4-oscillators","title":"1. Kuramoto dynamics (4 oscillators)","text":"<pre><code>from scpn_quantum_control.bridge import OMEGA_N_16, build_knm_paper27\nfrom scpn_quantum_control.phase import QuantumKuramotoSolver\n\nK = build_knm_paper27(L=4)\nomega = OMEGA_N_16[:4]\n\nsolver = QuantumKuramotoSolver(4, K, omega)\nresult = solver.run(t_max=0.5, dt=0.1, trotter_per_step=2)\n\nfor t, R in zip(result[\"times\"], result[\"R\"]):\n    print(f\"  t={t:.1f}: R={R:.4f}\")\n</code></pre> <p>The Kuramoto order parameter R measures phase synchronization: R=1 means all oscillators are in phase, R=0 means incoherent.</p>"},{"location":"quickstart/#2-vqe-ground-state","title":"2. VQE ground state","text":"<pre><code>from scpn_quantum_control.phase import PhaseVQE\nfrom scpn_quantum_control.bridge import build_knm_paper27, OMEGA_N_16\n\nK = build_knm_paper27(L=4)\nomega = OMEGA_N_16[:4]\n\nvqe = PhaseVQE(K, omega, ansatz_reps=2)\nsol = vqe.solve(optimizer=\"COBYLA\", maxiter=200)\nprint(f\"VQE energy:   {sol['ground_energy']:.6f}\")\nprint(f\"Exact energy: {sol['exact_energy']:.6f}\")\nprint(f\"Error:        {sol['energy_gap']:.6f}\")\n</code></pre> <p>On IBM hardware this achieves 0.05% error (4 qubits).</p>"},{"location":"quickstart/#3-run-a-hardware-experiment-on-simulator","title":"3. Run a hardware experiment on simulator","text":"<pre><code>from scpn_quantum_control.hardware import HardwareRunner\nfrom scpn_quantum_control.hardware.experiments import kuramoto_4osc_experiment\n\nrunner = HardwareRunner(use_simulator=True)\nrunner.connect()\n\nresult = kuramoto_4osc_experiment(runner, shots=10000, n_time_steps=4, dt=0.1)\nprint(f\"hw_R:  {result['hw_R']}\")\nprint(f\"exact: {result['classical_R']}\")\n</code></pre>"},{"location":"quickstart/#4-zne-error-mitigation","title":"4. ZNE error mitigation","text":"<pre><code>from scpn_quantum_control.hardware import HardwareRunner\nfrom scpn_quantum_control.hardware.experiments import kuramoto_4osc_zne_experiment\n\nrunner = HardwareRunner(use_simulator=True)\nrunner.connect()\n\nresult = kuramoto_4osc_zne_experiment(runner, shots=10000, scales=[1, 3, 5])\nprint(f\"R at scale 1: {result['R_per_scale'][0]:.4f}\")\nprint(f\"R at scale 5: {result['R_per_scale'][2]:.4f}\")\nprint(f\"ZNE R(0):     {result['zne_R']:.4f}\")\nprint(f\"Exact R:      {result['classical_R']:.4f}\")\n</code></pre> <p>ZNE (zero-noise extrapolation) runs the same circuit at increasing noise levels, then fits a polynomial to extrapolate to zero noise.</p>"},{"location":"quickstart/#5-full-16-layer-upde","title":"5. Full 16-layer UPDE","text":"<pre><code>from scpn_quantum_control.phase import QuantumUPDESolver\n\nsolver = QuantumUPDESolver()  # uses canonical SCPN parameters\nresult = solver.step(dt=0.05)\nprint(f\"R_global: {result['R_global']:.4f}\")\n</code></pre>"},{"location":"quickstart/#6-crypto-bell-test-on-simulator","title":"6. Crypto Bell test on simulator","text":"<pre><code>from scpn_quantum_control.hardware import HardwareRunner\nfrom scpn_quantum_control.hardware.experiments import bell_test_4q_experiment\n\nrunner = HardwareRunner(use_simulator=True)\nrunner.connect()\n\nresult = bell_test_4q_experiment(runner, shots=10000, maxiter=100)\nprint(f\"S_hw:  {result['S_hw']:.4f}\")\nprint(f\"S_sim: {result['S_sim']:.4f}\")\nprint(f\"Violates classical (S&gt;2): {result['violates_classical_hw']}\")\n</code></pre> <p>The Bell test prepares the VQE ground state of H(K_nm), measures in 4 basis combinations (ZZ, ZX, XZ, XX), and checks whether the CHSH S-value exceeds the classical bound of 2.</p>"},{"location":"quickstart/#available-experiments","title":"Available experiments","text":"<p>20 pre-built experiments in <code>ALL_EXPERIMENTS</code>:</p> <pre><code>from scpn_quantum_control.hardware.experiments import ALL_EXPERIMENTS\nfor name in sorted(ALL_EXPERIMENTS):\n    print(name)\n</code></pre> <p>See Experiment Roadmap for the full plan.</p>"},{"location":"quickstart/#running-examples","title":"Running examples","text":"<pre><code>python examples/01_qlif_demo.py           # Quantum LIF neuron\npython examples/02_kuramoto_xy_demo.py    # Kuramoto XY dynamics\npython examples/05_vqe_ansatz_comparison.py  # Ansatz benchmark\npython examples/06_zne_demo.py            # ZNE demo\n</code></pre>"}]}